.TH "SysIO::EndianReader" 3 "Sat Jun 19 2021" "Version 1.0" "Endian Stream" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SysIO::EndianReader \- A stream object that is aware of the endianness of the system, and the endianness of the file being read\&. the stream can translate the data to the systems native endianness as it reads in the data\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <endian_reader\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEndianReader\fP (const std::string &, const \fBByteOrder\fP &)"
.br
.RI "Load a file, and designate the endianness of the stream\&. "
.ti -1c
.RI "\fB~EndianReader\fP ()"
.br
.RI "Cleanup ifstream\&. "
.ti -1c
.RI "void \fBclose\fP ()"
.br
.RI "close the stream "
.ti -1c
.RI "void \fBseek\fP (const size_t &)"
.br
.RI "Goto a specific offset\&. "
.ti -1c
.RI "void \fBpad\fP (const size_t &)"
.br
.RI "Treats n bytes as padding, skipping over them\&. "
.ti -1c
.RI "size_t \fBtell\fP ()"
.br
.RI "Gets the current position in the stream\&. "
.ti -1c
.RI "std::string \fBreadString\fP (const size_t &)"
.br
.RI "Read a fixed length string from the stream\&. "
.ti -1c
.RI "std::string \fBreadString\fP ()"
.br
.RI "Read a null terminated string from the stream\&. "
.ti -1c
.RI "\fBByteArray\fP \fBreadRaw\fP (const size_t &, const size_t &)"
.br
.RI "Seek to an offset, read n bytes, and seek back original position\&. "
.ti -1c
.RI "\fBByteArray\fP \fBreadRaw\fP (const size_t &)"
.br
.RI "Read n bytes from current position\&. "
.ti -1c
.RI "template<class type > type \fBread\fP ()"
.br
.RI "Read some data from the stream\&. Creates a new instance of type\&. "
.ti -1c
.RI "template<class type > type \fBpeek\fP ()"
.br
.RI "Read some data from the stream, without updating stream position\&. Creates a new instance of type\&. "
.ti -1c
.RI "template<class type > \fBEndianReader\fP & \fBoperator>>\fP (type &data)"
.br
.RI "Read some data from the stream into an existing object\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "size_t \fBfileSize\fP {}"
.br
.RI "Size of the file on disk\&. "
.ti -1c
.RI "std::ifstream \fBfile\fP {}"
.br
.RI "Stream access to the file being read\&. "
.ti -1c
.RI "\fBByteOrder\fP \fBfileEndianness\fP {}"
.br
.RI "Endianness of the file, assigned at construction\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr const char * \fBEXCEPTION_FILE_ACCESS\fP {'Unable To Access Requested File\&.'}"
.br
.RI "EXCEPTION_FILE_ACCESS - 'Unable To Access Requested File\&.'\&. "
.ti -1c
.RI "static constexpr const char * \fBEXCEPTION_FILE_BOUNDS\fP {'Requested Offset Exceeds Bounds Of The File\&.'}"
.br
.RI "EXCEPTION_FILE_BOUNDS - 'Requested Offset Exceeds Bounds Of The File\&.'\&. "
.ti -1c
.RI "static const uint16_t \fBMAXIMUM_STRING_LENGTH\fP {0xffff}"
.br
.RI "MAXIMUM_STRING_LENGTH - 0xffff (65535) "
.in -1c
.SH "Detailed Description"
.PP 
A stream object that is aware of the endianness of the system, and the endianness of the file being read\&. the stream can translate the data to the systems native endianness as it reads in the data\&. 
.PP
Definition at line 20 of file endian_reader\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SysIO::EndianReader::EndianReader (const std::string & path, const \fBByteOrder\fP & endianness)"

.PP
Load a file, and designate the endianness of the stream\&. 
.PP
\fBParameters\fP
.RS 4
\fIstd::string\fP Path - File the stream is designated to read 
.br
\fIByteOrder\fP Endianness - Endianness of the file in question 
.RE
.PP

.PP
Definition at line 10 of file endian_reader\&.cpp\&.
.PP
.nf
10                                                                                  : fileEndianness(endianness)
11     {
12         // Try and open file
13         file\&.open(path, std::ios_base::in | std::ios_base::binary | std::ios_base::ate);
14         if(!file\&.is_open())
15             throw std::runtime_error(EXCEPTION_FILE_ACCESS);
16 
17         // Get the file size if successful\&.
18         fileSize = file\&.tellg();
19         file\&.seekg(0);
20         return;
21     }
.fi
.SS "SysIO::EndianReader::~EndianReader ()"

.PP
Cleanup ifstream\&. 
.PP
Definition at line 23 of file endian_reader\&.cpp\&.
.PP
.nf
24     {
25         // cleanup
26         close();
27     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void SysIO::EndianReader::close ()"

.PP
close the stream 
.PP
Definition at line 29 of file endian_reader\&.cpp\&.
.PP
.nf
30     {
31         file\&.close();
32     }
.fi
.SS "template<class type > \fBEndianReader\fP& SysIO::EndianReader::operator>> (type & data)\fC [inline]\fP"

.PP
Read some data from the stream into an existing object\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fItype\fP - Template type 
.RE
.PP
\fBParameters\fP
.RS 4
\fIdata\fP - Destination for the data read in from stream 
.RE
.PP
\fBReturns\fP
.RS 4
\fBEndianReader\fP& - Returns it's self for chaining of >> operators 
.RE
.PP

.PP
Definition at line 108 of file endian_reader\&.h\&.
.PP
.nf
109         {
110             // Read data from the stream, swap the endianness if needed\&.
111             file\&.read(reinterpret_cast<char*>( &data ), sizeof(data));
112             if (SysIO::systemEndianness != fileEndianness)
113                 SysIO::EndianSwap(data);
114             return *this;
115         };
.fi
.SS "void SysIO::EndianReader::pad (const size_t & n)"

.PP
Treats n bytes as padding, skipping over them\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize_t\fP n - Number of bytes as padding 
.RE
.PP

.PP
Definition at line 44 of file endian_reader\&.cpp\&.
.PP
.nf
45     {
46         // Skip over padding by seeking to the current position + padding size
47         seek( tell() + n );
48         return;
49     }
.fi
.SS "template<class type > type SysIO::EndianReader::peek ()\fC [inline]\fP"

.PP
Read some data from the stream, without updating stream position\&. Creates a new instance of type\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fItype\fP - Template Type 
.RE
.PP
\fBReturns\fP
.RS 4
type - A new instance of 'type' read from the stream and adjusted for endianness 
.RE
.PP

.PP
Definition at line 92 of file endian_reader\&.h\&.
.PP
.nf
93         {
94             // Read data of a certain type, seek the stream back, and return the data
95             type ret;
96             *this >> ret;
97 
98             seek( tell() - sizeof(type) );
99 
100             return ret;
101         }
.fi
.SS "template<class type > type SysIO::EndianReader::read ()\fC [inline]\fP"

.PP
Read some data from the stream\&. Creates a new instance of type\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fItype\fP - Template type 
.RE
.PP
\fBReturns\fP
.RS 4
type - A new instance of 'type' read from the stream and adjusted for endianness 
.RE
.PP

.PP
Definition at line 80 of file endian_reader\&.h\&.
.PP
.nf
81         {
82             // Read data of a certain type and return it\&.
83             type ret;
84             *this >> ret;
85             return ret;
86         }
.fi
.SS "\fBByteArray\fP SysIO::EndianReader::readRaw (const size_t & n)"

.PP
Read n bytes from current position\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize_t\fP n - Number for bytes to read 
.RE
.PP
\fBReturns\fP
.RS 4
ByteArray - Range of bytes requested 
.RE
.PP

.PP
Definition at line 103 of file endian_reader\&.cpp\&.
.PP
.nf
104     {
105         // If the end of the block exceeds the file size, we'll end up with an overflow\&.
106         if(tell() + n > fileSize)
107             throw std::runtime_error(EXCEPTION_FILE_BOUNDS);
108 
109         // Create a ByteArray of 'size' width\&. Read from the file into byte array
110         ByteArray ret(n);
111         file\&.read(reinterpret_cast<char*>(ret\&.data()), n);
112 
113         return ret;
114     }
.fi
.SS "\fBByteArray\fP SysIO::EndianReader::readRaw (const size_t & offset, const size_t & n)"

.PP
Seek to an offset, read n bytes, and seek back original position\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize_t\fP offset - Offset to start read from 
.br
\fIsize_t\fP n - Number of bytes to read 
.RE
.PP
\fBReturns\fP
.RS 4
ByteArray - Range of bytes requested 
.RE
.PP

.PP
Definition at line 85 of file endian_reader\&.cpp\&.
.PP
.nf
86     {
87         // Store the original position, and create a vector<byte> of the right size
88         const size_t initPos { tell() };
89         ByteArray ret(n);
90 
91         // If the end of the block exceeds the file size, we'll end up with an overflow\&.
92         if(offset + n > fileSize)
93             throw std::runtime_error(EXCEPTION_FILE_BOUNDS);
94 
95         // Seek to the beginning of the data, Read the data, then return to initPos
96         seek(offset);
97         file\&.read(reinterpret_cast<char*>(ret\&.data()), n);
98         seek(initPos);
99 
100         return ret;
101     }
.fi
.SS "std::string SysIO::EndianReader::readString ()"

.PP
Read a null terminated string from the stream\&. 
.PP
\fBReturns\fP
.RS 4
std::string - String read from stream 
.RE
.PP

.PP
Definition at line 67 of file endian_reader\&.cpp\&.
.PP
.nf
68     {
69         std::string ret;
70         char buffer;
71 
72         // For loop prevents infinite loop
73         for(size_t i = 0; i < MAXIMUM_STRING_LENGTH; ++i)
74         {
75             // Read a char at a time until we reach a null terminator\&.
76             file\&.read(&buffer, 1);
77             if(buffer == '\0')
78                 break;
79             ret\&.push_back(buffer);
80         };
81 
82         return ret;
83     }
.fi
.SS "std::string SysIO::EndianReader::readString (const size_t & size)"

.PP
Read a fixed length string from the stream\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize_t\fP size - Size of the string 
.RE
.PP
\fBReturns\fP
.RS 4
std::string - String read from stream 
.RE
.PP

.PP
Definition at line 57 of file endian_reader\&.cpp\&.
.PP
.nf
58     {
59         // Create a string large enough to hold the data\&.
60         std::string ret(size, '\0');
61 
62         // Read into, and return the string\&.
63         file\&.read(ret\&.data(), size);
64         return ret;
65     }
.fi
.SS "void SysIO::EndianReader::seek (const size_t & offset)"

.PP
Goto a specific offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize_t\fP Offset - Offset to the new stream position 
.RE
.PP

.PP
Definition at line 34 of file endian_reader\&.cpp\&.
.PP
.nf
35     {
36         // If requested offset exceeds the bounds of the file size\&. something is wrong\&.
37         if(offset > fileSize)
38             throw std::runtime_error(EXCEPTION_FILE_BOUNDS);
39         // If not seek and return;
40         file\&.seekg(offset);
41         return;
42     }
.fi
.SS "size_t SysIO::EndianReader::tell ()"

.PP
Gets the current position in the stream\&. 
.PP
\fBReturns\fP
.RS 4
size_t - Stream position 
.RE
.PP

.PP
Definition at line 51 of file endian_reader\&.cpp\&.
.PP
.nf
52     {
53         // Return the current position in the ifstream
54         return file\&.tellg();
55     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "constexpr const char* SysIO::EndianReader::EXCEPTION_FILE_ACCESS {'Unable To Access Requested File\&.'}\fC [static]\fP, \fC [constexpr]\fP"

.PP
EXCEPTION_FILE_ACCESS - 'Unable To Access Requested File\&.'\&. 
.PP
Definition at line 24 of file endian_reader\&.h\&.
.SS "constexpr const char* SysIO::EndianReader::EXCEPTION_FILE_BOUNDS {'Requested Offset Exceeds Bounds Of The File\&.'}\fC [static]\fP, \fC [constexpr]\fP"

.PP
EXCEPTION_FILE_BOUNDS - 'Requested Offset Exceeds Bounds Of The File\&.'\&. 
.PP
Definition at line 26 of file endian_reader\&.h\&.
.SS "std::ifstream SysIO::EndianReader::file {}"

.PP
Stream access to the file being read\&. 
.PP
Definition at line 33 of file endian_reader\&.h\&.
.SS "\fBByteOrder\fP SysIO::EndianReader::fileEndianness {}"

.PP
Endianness of the file, assigned at construction\&. 
.PP
Definition at line 35 of file endian_reader\&.h\&.
.SS "size_t SysIO::EndianReader::fileSize {}"

.PP
Size of the file on disk\&. 
.PP
Definition at line 31 of file endian_reader\&.h\&.
.SS "const uint16_t SysIO::EndianReader::MAXIMUM_STRING_LENGTH {0xffff}\fC [static]\fP"

.PP
MAXIMUM_STRING_LENGTH - 0xffff (65535) 
.PP
Definition at line 28 of file endian_reader\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Endian Stream from the source code\&.
